#!/usr/bin/env bash

# Define the output file
output_file="doc-package.nix"

# Navigate to the script's directory to ensure paths are handled correctly
cd "$(dirname "$0")"

# Find all options.nix files in /modules, relative to the /doc directory
options_files=$(find ../modules -type f -name "options.nix")

# Start the modules array
modules_array=()

# Populate the array with relative paths
for file in $options_files; do
    relative_path=$(realpath --relative-to="../" "$file")
    modules_array+=("$relative_path")
done

# Open output file for writing
exec > "$output_file"

# Print the initial part of the Nix expression up to the modules array
cat <<EOF
# DO NOT EDIT! This file is generated by ./update.sh
{
  lib,
  runCommand,
  nixosOptionsDoc,
  pkgs,
  ...
}: let
  inherit (lib) hasPrefix removePrefix;
  # evaluate our options
  eval = lib.evalModules {
    # The populated modules array
    modules = [
EOF

# Print each module path, formatted for Nix
for module in "${modules_array[@]}"; do
    echo "      ../${module}"
done

# Print the closing part of the Nix expression
cat <<EOF
    ];
  };

  # generate our docs
  optionsDoc = nixosOptionsDoc {
    options = eval.options.modules;
    transformOptions = opt:
      opt
      // {
        declarations =
          map
          (decl:
            if hasPrefix (toString ../..) (toString decl)
            then let
              subpath = removePrefix "/" (removePrefix (toString ../.) (toString decl));
            in {
              url = "https://github.com/jamesatintegratnio/nix-dots/blob/main/\${subpath}";
              name = subpath;
            }
            else decl)
          opt.declarations;
      };
    documentType = "none";
  };
in
  runCommand "index.md" {} ''
    cat \${optionsDoc.optionsCommonMark} >> \$out
  ''
EOF

# Close output redirection
exec >&-

# echo "Nix expression generated and saved to $output_file"
